### 1. 클라이언트 요청

* 클라이언트(브라우저, Postman, 앱 등)가 POST 요청 전송
* URL: `/api/articles`
* 본문(JSON):

<pre class="overflow-visible!" data-start="152" data-end="206"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"><span class="" data-state="closed"></span></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-json"><span><span>{</span><span>
  </span><span>"title"</span><span>:</span><span></span><span>"첫 글"</span><span>,</span><span>
  </span><span>"content"</span><span>:</span><span></span><span>"내용입니다"</span><span>
</span><span>}</span><span>
</span></span></code></div></div></pre>

---

### 2. 컨트롤러 (`BlogApiController`)

<pre class="overflow-visible!" data-start="249" data-end="372"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"><span class="" data-state="closed"></span></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>@PostMapping("/api/articles")</span><span>
</span><span>public</span><span> ResponseEntity<Article> </span><span>addArticle</span><span>(@RequestBody</span><span> AddArticleRequest request)
</span></span></code></div></div></pre>

* `@PostMapping("/api/articles")` → 이 URL의 POST 요청을 이 메서드로 매핑
* `@RequestBody AddArticleRequest request` → JSON 요청 본문을 `AddArticleRequest` DTO 객체로 변환
* 이제 `request` 안에는 `title`과 `content` 값이 들어 있음

---

### 3. 서비스 (`BlogService`)

<pre class="overflow-visible!" data-start="610" data-end="671"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"><span class="" data-state="closed"></span></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>Article</span><span></span><span>savedArticle</span><span></span><span>=</span><span> blogService.save(request);
</span></span></code></div></div></pre>

* 컨트롤러는 DTO를 서비스로 전달
* 서비스는 DTO를 엔티티(`Article`)로 변환 후, 리포지토리를 통해 DB에 저장
* DTO → Entity 변환은 보통 `request.toEntity()` 같은 메서드로 수행

---

### 4. 리포지토리 (`BlogRepository`)

<pre class="overflow-visible!" data-start="841" data-end="900"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"><span class="" data-state="closed"></span></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>return</span><span> blogRepository.save(request.toEntity());
</span></span></code></div></div></pre>

* 서비스가 호출
* JPA Repository `save()` → DB에 INSERT 수행
* 저장된 엔티티 객체 반환 (ID 포함)

---

### 5. 컨트롤러 반환

<pre class="overflow-visible!" data-start="1005" data-end="1107"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"><span class="" data-state="closed"></span></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>return</span><span> ResponseEntity.status(HttpStatus.CREATED)
                     .body(savedArticle);
</span></span></code></div></div></pre>

* 저장된 엔티티를 HTTP Response Body로 반환
* 클라이언트는 JSON 형태로 저장된 글 데이터를 받음

---

### 🔹 데이터 흐름 그림으로 요약

<pre class="overflow-visible!" data-start="1206" data-end="1460"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"><span class="" data-state="closed"></span></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre!"><span><span>클라이언트(</span><span>JSON</span><span>) 
      ↓
</span><span>@RequestBody</span><span> → </span><span>AddArticleRequest</span><span>(</span><span>DTO</span><span>)
      ↓
</span><span>BlogService</span><span>.</span><span>save</span><span>(request) 
      ↓
request.</span><span>toEntity</span><span>() → </span><span>Article</span><span>(</span><span>Entity</span><span>)
      ↓
blogRepository.</span><span>save</span><span>(</span><span>Article</span><span>)
      ↓
저장된 </span><span>Article</span><span> 반환
      ↓
컨트롤러 </span><span>ResponseEntity</span><span>
      ↓
클라이언트(</span><span>JSON</span><span>)
</span></span></code></div></div></pre>

* DTO는 **계층 간 데이터 전달 역할**
* 컨트롤러 → 서비스 → 리포지토리 순서로 흐름
* JPA Repository가 DB 접근 담당
