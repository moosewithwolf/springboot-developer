
네, 코드를 모두 합쳤을 때 전체 흐름이 어떻게 연결되는지 파악하기 어려울 수 있습니다. 회원가입과 로그인의 두 가지 시나리오로 나누어, **큰 그림부터 세부 코드까지 연결해서** 설명해 드리겠습니다.

---

### ## 큰 그림: 보안 설정된 클럽 입장하기

먼저, `WebSecurityConfig` 파일은 우리 웹사이트라는 **'회원제 클럽'의 보안 규칙집**입니다. 스프링 시큐리티는 이 규칙을 집행하는 똑똑한 **'보안요원(Bouncer)'** 역할을 합니다.

**보안 규칙집(`WebSecurityConfig`)의 핵심 내용:**

* "클럽의 메인 라운지(`/articles` 등)는 **회원만(authenticated)** 들어올 수 있다."
* "클럽 입구(`/login`)와 회원가입 데스크(`/signup`)는 **누구나(permitAll)** 올 수 있다."
* "회원이 되려면, 가입 데스크에서 **신청서(`POST /user`)**를 작성해야 한다."
* "회원임을 증명하려면, 입구에서 **로그인 폼을 작성**해야 한다." (`formLogin()`)

이 규칙을 바탕으로 두 가지 시나리오가 어떻게 동작하는지 살펴보겠습니다.

---

### ## 시나리오 1: 신규 회원가입 과정 📝

 **목표** : 비회원이 클럽 명단(DB)에 자신의 이름을 올리는 과정입니다.

1. **가입 페이지로 이동 (`GET /signup`)**
   * **사용자** : 회원가입 링크를 클릭합니다.
   * **동작** : `UserViewController`의 `@GetMapping("/signup")` 메소드가 이 요청을 받습니다.
   * **결과** : `"signup"`이라는 문자열을 반환하고, 스프링은 `signup.html` 뷰(회원가입 폼)를 사용자에게 보여줍니다.
2. **가입 정보 제출 (`POST /user`)**
   * **사용자** : 이메일과 비밀번호를 입력하고 '가입하기' 버튼을 누릅니다.
   * **동작** : `UserApiController`의 `@PostMapping("/user")` 메소드가 이 요청을 받습니다. `AddUserRequest` DTO가 사용자가 입력한 이메일과 비밀번호를 자동으로 담아냅니다.
   * **결과** : 컨트롤러는 받은 `request` 객체를 `userService.save(request)` 메소드로 넘깁니다.
3. **회원 정보 저장 (Service → Repository)**
   * **사용자** : 대기 중...
   * **동작** : `UserService`의 `save()` 메소드가 실행됩니다.
   * **1단계 (비밀번호 암호화)** : `WebSecurityConfig`에 Bean으로 등록된 `bCryptPasswordEncoder`를 사용해 사용자의 비밀번호를 암호화(`encode()`)합니다.
   * **2단계 (DB 저장)** : 암호화된 비밀번호와 이메일을 `User` 엔티티 객체로 만든 뒤, `UserRepository`의 `save()` 메소드를 호출하여 DB에 저장합니다. 이제 이 사용자는 클럽의 '회원 명단'에 정식으로 등록되었습니다.
   * **결과** : `UserApiController`는 `save()`가 완료된 후 `"redirect:/login"`을 반환합니다.
4. **로그인 페이지로 이동**
   * **사용자** : 회원가입이 완료되고 자동으로 로그인 페이지로 이동됩니다.
   * **동작** : 브라우저는 서버로부터 "이제 `/login`으로 가세요" 라는 지시를 받고, 해당 페이지를 다시 요청합니다.

---

### ## 시나리오 2: 기존 회원 로그인 과정 🔑

 **목표** : 이미 명단에 있는 회원이 보안요원의 검사를 통과하고 클럽에 들어가는 과정입니다.

1. **로그인 시도 (`POST /login`)**
   * **사용자** : `/login` 페이지에서 이메일과 비밀번호를 입력하고 '로그인' 버튼을 누릅니다.
   * **동작 (매우 중요!)** : 이 `POST /login` 요청은 우리가 만든 **컨트롤러가 가로채지 않습니다.** `WebSecurityConfig`의 `.formLogin()` 설정 때문에, **스프링 시큐리티 보안요원이 직접** 이 요청을 가로채서 인증 절차를 시작합니다.
2. **신원 확인 (Authentication)**
   * **사용자** : 대기 중...
   * **동작** : 스프링 시큐리티(보안요원)가 **인증 관리자(AuthenticationManager)**를 통해 신원 확인을 시작합니다. `WebSecurityConfig`에 설정된 규칙에 따라 다음과 같이 동작합니다.
   * **1단계 (회원 명단 조회)** : "이 손님(`email`)이 명단에 있는지 확인해야겠다." → 우리가 만든 **`UserDetailService`**의 `loadUserByUsername(email)` 메소드를 호출합니다.
   * **2단계 (DB에서 정보 가져오기)** : `UserDetailService`는 `UserRepository`의 `findByEmail(email)`을 호출하여 DB에서 해당 사용자의 정보(`User` 엔티티)를 찾아옵니다. 사용자가 없으면 예외를 발생시키고 인증은 실패합니다.
   * **3단계 (비밀번호 비교)** : 사용자가 있다면, DB에서 가져온  **암호화된 비밀번호** (from `user.getPassword()`)와 손님이 방금 입력한 **날것의 비밀번호**를 `BCryptPasswordEncoder`를 사용해 비교합니다. 일치하지 않으면 인증은 실패합니다.
3. **인증 성공 및 입장**
   * **사용자** : 비밀번호가 일치하면 로그인이 성공하고, 메인 페이지로 이동합니다.
   * **동작** : 인증이 성공하면, 스프링 시큐리티는 사용자를 위한 **'인증된 세션'**을 만들어줍니다. (클럽 입장 팔찌를 채워주는 것과 같습니다.)
   * **결과** : `WebSecurityConfig`에 설정된 `.defaultSuccessUrl("/articles")` 규칙에 따라 사용자를 `/articles` 페이지로 리디렉션시킵니다.

이제 사용자는 '인증된 팔찌'를 차고 있으므로, 보안요원은 `/articles` 같은 회원 전용 구역에 접근할 때마다 얼굴을 확인하지 않고 팔찌만 보고 바로 통과시켜 줍니다

### 로그인 흐름 관련 코드 흐름

네, 정확합니다. 그 흐름은 개발자가 작성한 코드에 직접적으로 보이지 않고, **스프링 시큐리티 프레임워크가 내부적으로 처리**하기 때문에 그렇습니다. 프레임워크를 사용한다는 것은 바로 이런 '보이지 않는 자동화'의 도움을 받는다는 의미이기도 합니다.

이 '보이지 않는 흐름'의 중심에는 **`UsernamePasswordAuthenticationFilter`**라는 부품이 있습니다.

---

### ## "보이지 않는 보안요원": 필터 체인(Filter Chain) 👮

`WebSecurityConfig`에서 `.build()`를 호출하여 `SecurityFilterChain` Bean을 등록하면, 스프링 시큐리티는 **여러 개의 보안 필터(Filter)들로 이루어진 체인**을 만듭니다. 클럽 입구에 눈에 보이지 않는 여러 명의 전문 보안요원들이 줄지어 서 있다고 상상해보세요.

모든 HTTP 요청은 우리가 만든 컨트롤러에 도달하기 전에, 반드시 이 보안 필터 체인을 순서대로 통과해야 합니다.

* **1번 요원 (CsrfFilter)** : "위조된 요청은 아닌가?" 검사
* **2번 요원 (UsernamePasswordAuthenticationFilter)** : " **혹시 이거... 로그인 시도인가?** " 검사 ⬅️ **바로 이 녀석이 주인공입니다.**
* **3번 요원 (AuthorizationFilter)** : "인증된 사용자인가? 이 방에 들어갈 권한은 있나?" 검사
* ... (기타 여러 필터들) ...
* **최종 통과** : 모든 필터를 통과하면 그제서야 우리가 만든 `Controller`로 요청이 전달됩니다.

---

### ## 로그인 흐름의 실제 주인공: `UsernamePasswordAuthenticationFilter`

사용자가 `/login` 경로로 아이디와 비밀번호를 `POST` 방식으로 보내면, 다음과 같은 일이 벌어집니다.

1. **요청 도착** : `POST /login` 요청이 서버에 도착하여 필터 체인으로 들어옵니다.
2. **`UsernamePasswordAuthenticationFilter`의 차례** : 2번 요원이 이 요청을 검사합니다. `WebSecurityConfig`의 `.formLogin()` 설정 때문에, 이 필터는 **`POST /login` 요청을 감시**하도록 프로그래밍되어 있습니다.
3. **요청 가로채기 (Intercept)** : 필터는 "아! 이건 로그인 시도다. 내 담당이다."라고 판단하고 요청을 **가로챕니다.** 이 시점에서 요청은 더 이상 진행되지 않고, **우리가 만든 `Controller`에는 절대 도달하지 않습니다.**
4. **`AuthenticationManager`에 위임** : 필터는 가로챈 요청에서 아이디와 비밀번호를 추출한 뒤, 자신이 직접 처리하지 않고 **인증 전문가인 `AuthenticationManager`(인증 관리자)에게 "이 정보 진짜인지 확인 좀 해주세요"라고 위임**합니다.
5. **익숙한 흐름 시작** : `AuthenticationManager`는 `WebSecurityConfig`에서 우리가 설정한 대로, `UserDetailService`를 호출하여 DB에서 사용자 정보를 가져오고, `BCryptPasswordEncoder`로 비밀번호를 비교하는, **이전 답변에서 설명한 바로 그 신원 확인 절차**를 수행합니다.

---

### ## 그래서 코드에서 어떻게 알 수 있나?

바로 `WebSecurityConfig`의 **선언적인 코드**가 그 증거이자 설명서입니다.

* **`.formLogin()`** : 이 한 줄의 코드가 스프링에게 "`UsernamePasswordAuthenticationFilter`를 활성화하고, `POST /login` 요청을 감시하도록 설정해줘" 라고 지시하는 것입니다.
* **`authenticationManager()` Bean 설정** : 이 코드는 `UsernamePasswordAuthenticationFilter`가 사용할 인증 전문가(`AuthenticationManager`)를 우리가 직접 만든다는 선언입니다.

즉, 개발자는 **'어떤 필터를, 어떻게 설정해서, 필터 체인에 끼워넣을지'**를 `WebSecurityConfig`를 통해 선언적으로 지시하는 것입니다. 실제 필터들의 동작과 호출 흐름은 프레임워크가 약속대로 알아서 처리해줍니다.

네, 그 부분은 스프링 시큐리티가 **자동으로 처리**해주기 때문에 직접 코드를 보지 못하신 게 맞습니다. 이전 로그인 과정에서 세션이 어떻게 사용되었는지, 그리고 토큰 방식과 무엇이 다른지 설명해 드릴게요.

---

### ## 서버 기반 인증 (세션 방식) - '클럽 팔찌' 비유 🎟️

이전 장에서 구현한 로그인은 **서버 기반 인증(세션 방식)**입니다. 마치 클럽에 입장할 때 받는 **'입장 팔찌'**와 같습니다.

1. **로그인 성공 (신원 확인 및 팔찌 발급)**
   * 사용자가 아이디/비밀번호로 로그인을 성공하면, 서버는 "이 사람은 인증된 사용자야"라는 사실을 기억해야 합니다.
   * 이를 위해 서버는 **자신의 메모리(세션 저장소)에 "고유한 보관함(세션)"**을 하나 만듭니다. 이 보관함에는 해당 사용자의 정보(누구인지, 어떤 권한이 있는지 등)가 들어있습니다.
   * 그리고 이 보관함에 접근할 수 있는 **"특별한 열쇠 번호(세션 ID)"**를 생성해서, 사용자의 웹 브라우저에 **쿠키(Cookie)** 형태로 몰래 보냅니다. 이 쿠키가 바로 '입장 팔찌'입니다.
2. **로그인 후 다른 페이지 접근**
   * 사용자가 로그인 후 다른 페이지(예: `/articles`)를 요청할 때, 웹 브라우저는 **자동으로** 가지고 있던 쿠키(입장 팔찌)를 서버에 함께 보냅니다.
   * 서버는 요청과 함께 온 쿠키의 '열쇠 번호(세션 ID)'를 봅니다.
   * 서버는 자신의 메모리(세션 저장소)에서 해당 번호의 보관함을 찾아보고, "아, 이 사람은 아까 인증받았던 홍길동이구나. 통과!"라고 판단하여 페이지를 보여줍니다.

 **결론** : 이 모든 과정은 스프링 시큐리티가 자동으로 처리해주므로, 개발자가 세션을 만들거나 쿠키를 보내는 코드를 직접 작성하지 않아도 로그인 상태가 유지되는 것입니다.

---

### ## 토큰 기반 인증 - '자유이용권' 비유 🎫

반면, 본문에서 설명하는 **토큰 기반 인증**은 조금 다릅니다. 이는 **'암호화된 자유이용권'**과 같습니다.

1. **로그인 성공 (자유이용권 발급)**
   * 사용자가 로그인을 성공하면, 서버는 사용자의 정보와 권한, 그리고 유효기간이 **암호화된 '토큰(JWT 등)'** 자체를 생성해서 사용자에게 직접 줍니다.
   * 서버는 이 토큰에 대해 아무것도 기억하지 않습니다. (세션 저장소 같은 보관함이 필요 없습니다.)
2. **로그인 후 다른 페이지 접근**
   * 사용자는 요청할 때마다 이 '자유이용권(토큰)'을 **직접** 제시해야 합니다. (보통 HTTP 헤더에 담아서 보냅니다.)
   * 서버는 토큰을 받아서 위조되지 않았는지, 유효기간이 지나지 않았는지만 검증합니다. 토큰 안에 "이 사람은 홍길동이고, user 권한이 있다"는 정보가 모두 들어있기 때문에, 서버는 자신의 메모리를 뒤져볼 필요 없이 바로 사용자를 신뢰하고 요청을 처리합니다.

---

### ## 핵심 차이점

| 구분                     | 서버 기반 인증 (세션)                                    | 토큰 기반 인증                                       |
| ------------------------ | -------------------------------------------------------- | ---------------------------------------------------- |
| **상태 저장 위치** | **서버**(세션 저장소)                              | **클라이언트**(토큰 자체에 정보 포함)          |
| **상태 유지 방식** | 서버가 발급한 세션 ID를 쿠키에 저장                      | 서버가 발급한 토큰을 클라이언트가 직접 저장          |
| **확장성**         | 서버가 여러 대가 되면 세션 정보를 공유해야 해서 복잡해짐 | 토큰만 검증하면 되므로 서버 확장(스케일 아웃)에 유리 |
| **주요 사용처**    | 전통적인 웹사이트                                        | SPA, 모바일 앱, 외부 API 연동 등                     |

결론적으로, 이전에 구현한 방식은 스프링 시큐리티가 **자동으로 세션과 쿠키를 관리**해주는 편리한 방식이었고, 본문에서 새로 소개하는 토큰 방식은
